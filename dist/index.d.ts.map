{"version":3,"sources":["../src/index.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AACzC,OAAc,EAAE,UAAU,EAAE,MAAM,OAAO,CAAC;AAE1C,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC/C,OAAO,EAAE,OAAO,IAAI,UAAU,EAAE,MAAM,cAAc,CAAC;AAIrD,oBAAY,iBAAiB,GAAG;IAC9B,qBAAqB,EAAE,OAAO,CAAC;IAC/B,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC;IACtB,wBAAwB,EAAE,MAAM,CAAC;IACjC,uBAAuB,EAAE,OAAO,CAAC;IACjC,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;CAC9B,CAAC;AACF,oBAAY,WAAW,GAAG,UAAU,GAAG,MAAM,GAAG,QAAQ,CAAC;AACzD,MAAM,WAAW,iBAAiB;IAChC,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,kBAAkB,CAAC,EAAE,eAAe,CAAC;CACtC;AAED,MAAM,WAAW,OAAO;IACtB,QAAQ,EAAE,SAAS,CAAC;IACpB,UAAU,EAAE,KAAK,CAAC,aAAa,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC;IACxD,QAAQ,CAAC,EAAE,MAAM,iBAAiB,GAAG,IAAI,CAAC;CAC3C;AACD,MAAM,WAAW,OAAO;IACtB,QAAQ,EAAE,OAAO,CAAC;IAClB,MAAM,EAAE,WAAW,GAAG,IAAI,CAAC;IAC3B,YAAY,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CACtC;AACD,MAAM,WAAW,aAAc,SAAQ,OAAO,CAAC,UAAU,CAAC;IACxD,aAAa,CAAC,EAAE,OAAO,CAAC;IACxB,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B,SAAS,CAAC,EAAE,IAAI,CAAC;CAClB;AACD,UAAU,UAAW,SAAQ,aAAa;IACxC,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,KAAK,CAAC,EAAE,GAAG,CAAC;CACb;AA4DD,wBAAgB,SAAS,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,IAAI,CAMtD;AAoJD;;;;GAIG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,aAAa,GAAG,IAAI,CAyBjD;AAuDD,wBAAgB,SAAS,CAAC,YAAY,EAAE,MAAM,GAAG,IAAI,CAEpD;AAED,wBAAgB,SAAS,CAAC,SAAS,EAAE,OAAO,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAKrE;AAED,wBAAgB,SAAS,IAAI,iBAAiB,CAE7C;AAED,wBAAgB,QAAQ,IAAI,UAAU,GAAG,IAAI,CAE5C;AAED,wBAAgB,SAAS,IAAI,WAAW,GAAG,IAAI,CAE9C;AAID,qBAAa,cAAe,SAAQ,KAAK,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC;gBACvD,KAAK,EAAE,OAAO;IAU1B,kBAAkB,IAAI,IAAI;IAM1B,aAAa,CAAC,MAAM,EAAE,WAAW,GAAG,MAAM,GAAG,IAAI;IAsBjD,iBAAiB,CAAC,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,CAAC,SAAS,GAAG,IAAI;IAS/D,oBAAoB,IAAI,IAAI;IAU5B,MAAM,IAAI,SAAS;CAYpB","file":"index.d.ts","sourcesContent":["import React, { ReactNode } from \"react\";\nimport axios, { AxiosError } from \"axios\";\nimport StackTrace from \"sourcemapped-stacktrace\";\nimport { ErrorAlertProps } from \"./ErrorAlert\";\nexport { default as ErrorAlert } from \"./ErrorAlert\";\nlet windowOnerrorTimeout: NodeJS.Timeout | number | null;\nlet windowOnerrorReference: ReactError;\n\nexport type ErrorReportConfig = {\n  disable_slack_posting: boolean;\n  header: string | null;\n  max_network_request_data: number;\n  override_window_onerror: boolean;\n  slack_webhook: string | null;\n};\nexport type ErrorStatus = \"detected\" | \"sent\" | \"failed\";\nexport interface OnErrorCBResponse {\n  prefix?: string;\n  custom_error_props?: ErrorAlertProps;\n}\n\nexport interface ERProps {\n  children: ReactNode;\n  ErrorAlert: React.ComponentType<ErrorAlertProps> | null;\n  callback?: () => OnErrorCBResponse | null;\n}\nexport interface ERState {\n  hasError: boolean;\n  status: ErrorStatus | null;\n  custom_props: { [key: string]: any };\n}\nexport interface ExtendedError extends Partial<AxiosError> {\n  network_error?: boolean;\n  additional_message?: string;\n  timestamp?: Date;\n}\ninterface ReactError extends ExtendedError {\n  component_trace?: string;\n  stack?: any;\n}\n\nlet config: ErrorReportConfig = {\n  disable_slack_posting: false,\n  header: null,\n  max_network_request_data: 400,\n  override_window_onerror: false,\n  slack_webhook: null\n};\n\nlet error: ReactError | null = null;\nlet errorStatus: ErrorStatus | null = null;\nconst listeners: ((status: ErrorStatus) => string | null)[] = [];\n\n//\n//\n/////////////////////\n//POSTING FUNCTIONS\n\nfunction postToSlack(msg: string): Promise<void> {\n  const postStack = new Error().stack;\n  return new Promise((resolve, reject) => {\n    if (!config.slack_webhook) {\n      const err = new Error(\n        \"ErrReporting: Property 'slack_webhook' not specified in config.\"\n      );\n      err.stack = postStack;\n      console.error(err);\n      reject(err);\n      return;\n    }\n    if (config.disable_slack_posting) {\n      console.log(\n        \"ErrReporting: Not sent because of disable_slack_posting flag!\"\n      );\n      resolve();\n      return;\n    }\n\n    const payload = encodeURIComponent(JSON.stringify({ text: msg }));\n\n    axios({\n      url: config.slack_webhook,\n      headers: {\n        \"content-type\": \"application/x-www-form-urlencoded\"\n      },\n      method: \"POST\",\n      data: \"payload=\" + payload\n    })\n      .then(() => {\n        console.log(\"ErrReporting: Successfully posted to slack.\");\n        resolve();\n      })\n      .catch(err => {\n        console.error(\"ErrReporting: Failed to post to slack.\");\n        reject(err);\n      });\n  });\n}\n\nexport function sendDebug(msg: string | string[]): void {\n  if (Array.isArray(msg)) {\n    postToSlack(msg.join(\"\\n\"));\n  } else {\n    postToSlack(msg);\n  }\n}\n///////////////////////////////\n///////////////////////////////\n///////////////////////////////\n///////////////////////////////\n///////////////////////////////\n///////////////////////////////\n//MESSAGE COMPOSITION FUNCTIONS\n\nfunction composeNetworkErrMessage(err: ReactError): string {\n  let msg = \"NETWORK ERROR: at \";\n  if (err.timestamp) {\n    msg += err.timestamp.toISOString();\n  } else {\n    msg += new Date().toISOString();\n  }\n  msg += \" \";\n  let cfg = \"\";\n  if (err.config) {\n    cfg = \"URL: \" + err.config.url + \", \" + err.config.method;\n    cfg +=\n      err.config.headers && err.config.headers.Authorization\n        ? \" (Auth header sent)\\n\"\n        : \"(NO Auth header)\\n\";\n    if (err.config.data) {\n      cfg +=\n        //NOTE: JSON.stringify() is NOT guaranteed to return a string, when passing in undefined it returns typeof undefined!\n        \"DATA SENT: '\" +\n        (JSON.stringify(err.config.data) + \"\").substr(\n          0,\n          config.max_network_request_data\n        ) +\n        \"'\\n\";\n    } else {\n      cfg += \"NO DATA SENT\";\n    }\n  } else {\n    cfg = \"NO NETWORK REQUEST axios CONFIG FOUND.\";\n  }\n\n  if (err.response) {\n    let data = JSON.stringify(err.response.data);\n    if (!data) {\n      data = \"''\";\n    } else {\n      data = \"'\" + data + \"'\";\n    }\n    let headers = JSON.stringify(err.response.headers);\n    if (!headers) {\n      headers = \"''\";\n    } else {\n      headers = \"'\" + headers + \"'\";\n    }\n    msg += \"\\nResponse data: \" + data;\n    msg += \"\\nResponse status: \" + err.response.status;\n    msg += \"\\nResponse headers: \" + headers;\n    msg += \"\\n\" + cfg;\n  } else if (err.request) {\n    msg += \"Probably OPTIONS failed! No response was given.\";\n    msg += \"\\n\" + cfg;\n  } else {\n    msg +=\n      \"Unknown error; response and request data undefined. NO HTTP STATUS CODE :(\";\n    msg += \"\\n\" + cfg;\n  }\n  return msg;\n}\n\nfunction composeErrMessage(err: ReactError): string {\n  let msg = \"NETWORK ERROR: at \";\n  if (err.timestamp) {\n    msg += err.timestamp.toISOString();\n  } else {\n    msg += new Date().toISOString();\n  }\n  msg += \" \";\n  return msg;\n}\n\nfunction resolveStack(err: ReactError): Promise<string[]> {\n  return new Promise(resolve => {\n    if (err.stack) {\n      StackTrace.mapStackTrace(err.stack, resolvedTrace => {\n        resolve(resolvedTrace);\n      });\n    } else {\n      resolve([\"NO STACK IN ERROR OBJECT\"]);\n    }\n  });\n}\n\nfunction composeMessage(\n  err: ReactError,\n  prefix: string | null = null\n): Promise<string> {\n  let head = config.header || \"\";\n  head +=\n    location.protocol +\n    location.hostname +\n    \" '\" +\n    location.pathname +\n    \"'\" +\n    \"\\n\";\n  head += \"Created at \" + new Date().toISOString() + \"\\n\";\n  if (prefix) {\n    head += prefix;\n  }\n  head += \"\\nERROR: \" + err.message + \"\\n\";\n  if (err.additional_message) {\n    head += err.additional_message + \"\\n\";\n  }\n\n  const body = err.network_error\n    ? composeNetworkErrMessage(err)\n    : composeErrMessage(err);\n\n  let trace = \"\";\n  if (err.component_trace) {\n    trace += err.component_trace + \"\\n---------\\n\";\n  }\n  return resolveStack(err).then(resolvedStack => {\n    if (Array.isArray(resolvedStack)) {\n      trace += resolvedStack.join(\"\\n\");\n    }\n    return head + \"\\n\" + body + \"\\n\" + trace;\n  });\n}\n\n//END OF MESSAGE COMPOSITION\n//\n//\n//\n//\n\nfunction setStatus(status: ErrorStatus): string {\n  errorStatus = status;\n  let prefixes = \"\";\n\n  listeners.forEach(listenerCB => {\n    const prefix = listenerCB(status);\n    if (prefix) {\n      prefixes += prefix;\n    }\n  });\n\n  return prefixes;\n}\n\n/**\n * Add property `network_error: true` to the error object to signal to the error reporter that it should\n * look for network related properties and network request data.\n * Use property `additional_message: <string>` on the error object to add additional data to the error report.\n */\nexport function setError(err: ExtendedError): void {\n  if (windowOnerrorReference === err) {\n    //If window.onerror has already caught this error we clear its timeout\n    //and handle it in this subsequent error catch.\n    if (windowOnerrorTimeout) {\n      clearTimeout(windowOnerrorTimeout as NodeJS.Timeout);\n    }\n  }\n  if (axios.isCancel(err)) {\n    //This is true when we have manually cancelled a network request.\n    return;\n  }\n  error = err;\n  const prefix = setStatus(\"detected\");\n  composeMessage(err, prefix)\n    .then(msg => {\n      console.log(\"Error report generated:\", msg);\n      return postToSlack(msg);\n    })\n    .then(() => {\n      setStatus(\"sent\");\n    })\n    .catch(() => {\n      setStatus(\"failed\");\n    });\n}\n\n////////////////\n////////////////\n////////////////\n////////////////\n//INITIAL ERROR LISTENER ATTACHING\n\nconst onerrorListener = (\n  message: Event | string,\n  source?: string,\n  lineno?: number,\n  colno?: number,\n  err?: ExtendedError\n): boolean => {\n  if (!err) {\n    if (typeof message === \"string\") {\n      err = new Error(\"ONLY STRING PROVIDED: \" + message);\n    } else {\n      err = new Error(\"INVALID CALL TO window.onerror. CANNOT RESOLVE.\");\n    }\n  }\n  windowOnerrorTimeout = setTimeout(() => {\n    //This timeout is here because shortly after window.onerror the React Error Boundary will\n    //trigger if the error was caused inside a React Component life cycle.\n    //The Error Boundary has more information and will cancel this timeout to ensure we do\n    //not post the same error report twice.\n    windowOnerrorTimeout = null;\n    if (err) {\n      if (!err.additional_message) {\n        err.additional_message = \"CAUGHT BY WINDOW.ONERROR.\";\n      } else {\n        err.additional_message += \" CAUGHT BY WINDOW.ONERROR.\";\n      }\n      setError(err);\n    }\n  }, 500);\n  windowOnerrorReference = err;\n  return true;\n};\n\nif (!window.onerror) {\n  window.onerror = onerrorListener;\n  console.log(\"ErrReporting: Listening to window.onerror\");\n} else if (window.onerror !== onerrorListener) {\n  console.log(\n    \"ErrReporting: window.onerror already assigned. Use setConfig({ override_window_onerror: true }) to override.\"\n  );\n}\n\n////////////////\n////////////////\n////////////////\n////////////////\n\nexport function setHeader(headerString: string): void {\n  config.header = headerString;\n}\n\nexport function setConfig(configObj: Partial<ErrorReportConfig>): void {\n  config = Object.assign({}, config, configObj);\n  if (config.override_window_onerror) {\n    window.onerror = onerrorListener;\n  }\n}\n\nexport function getConfig(): ErrorReportConfig {\n  return Object.assign({}, config);\n}\n\nexport function getError(): ReactError | null {\n  return error;\n}\n\nexport function getStatus(): ErrorStatus | null {\n  return errorStatus;\n}\n\n//\n//\nexport class ErrorReporting extends React.Component<ERProps, ERState> {\n  constructor(props: ERProps) {\n    super(props);\n\n    this.state = {\n      hasError: false,\n      status: null,\n      custom_props: {}\n    };\n  }\n\n  componentWillMount(): void {\n    listeners.push(status => {\n      return this.errorListener(status);\n    });\n  }\n\n  errorListener(status: ErrorStatus): string | null {\n    //This is to ensure component will re-render when the status of error changes.\n\n    let prefix: string | null = null;\n    let custom_props: { [key: string]: any } = {};\n    if (this.props.callback) {\n      const CBReturn = this.props.callback();\n      if (CBReturn) {\n        prefix = CBReturn.prefix ? CBReturn.prefix : null;\n        custom_props = CBReturn.custom_error_props\n          ? CBReturn.custom_error_props\n          : {};\n      }\n    }\n    this.setState({\n      hasError: true,\n      status: status,\n      custom_props: custom_props\n    });\n    return prefix;\n  }\n\n  componentDidCatch(err: ReactError, info: React.ErrorInfo): void {\n    this.setState({\n      hasError: true\n    });\n\n    err.component_trace = info.componentStack;\n    setError(err);\n  }\n\n  componentWillUnmount(): void {\n    //Remove listener callback so that we don't get called after we're removed or are kept in memory for no reason.\n    const listenerIndex = listeners.findIndex(\n      listener => listener === this.errorListener\n    );\n    if (listenerIndex > -1) {\n      listeners.splice(listenerIndex, 1);\n    }\n  }\n\n  render(): ReactNode {\n    const EA = this.props.ErrorAlert;\n    if (this.state.hasError && EA) {\n      return (\n        <EA status={getStatus()} custom_error_props={this.state.custom_props} />\n      );\n    } else if (this.state.hasError && EA === null) {\n      return null;\n    }\n\n    return this.props.children;\n  }\n}\n"]}